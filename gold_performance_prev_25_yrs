#!/usr/bin/env python
# -*- coding: utf-8 -*-

"""
gold_and_cpi.py

Pulls daily gold price data from Yahoo Finance, CPI YoY from a local SQL Server,
and the S&P 500 index from Yahoo Finance.

- Adjusts gold for inflation using cumulative CPI.
- Computes YoY changes for nominal gold, inflation-adjusted gold, CPI YoY, and S&P 500.
- Produces two shaded comparison charts, each with a monthly table beneath:
    1) Gold (nominal) YoY vs CPI YoY
    2) Gold (nominal) YoY vs S&P 500 YoY

Notes:
- Yahoo can be flaky by region/network. Fetchers retry and fall back when possible.
- A 20-second pause is inserted between fetching gold and S&P 500 from Yahoo.
"""

# ------------------------------------------------------------------
# Imports
# ------------------------------------------------------------------
import time
import pandas as pd
import yfinance as yf
import pyodbc

import matplotlib.pyplot as plt
import matplotlib.dates as mdates


# ------------------------------------------------------------------
# Utilities
# ------------------------------------------------------------------

def _normalize_index(df: pd.DataFrame) -> pd.DataFrame:
    """Ensure a single-level, tz-naive DatetimeIndex; drop extra index levels & duplicates."""
    df = df.copy()
    if isinstance(df.index, pd.MultiIndex):
        df = df.reset_index(level=list(range(1, df.index.nlevels)), drop=True)
    df.index = pd.to_datetime(df.index)
    try:
        df.index = df.index.tz_localize(None)
    except Exception:
        pass
    df = df[~df.index.duplicated(keep="last")].sort_index()
    return df


def _flatten_columns(df: pd.DataFrame) -> pd.DataFrame:
    """Flatten MultiIndex columns by taking the FIRST level name."""
    if isinstance(df.columns, pd.MultiIndex):
        df = df.copy()
        df.columns = [str(col[0]) if isinstance(col, tuple) else str(col) for col in df.columns]
    return df


# ------------------------------------------------------------------
# -------------------- Part 1 – Yahoo Finance helpers --------------------
# ------------------------------------------------------------------

def _try_yahoo_history(ticker: str, retries: int = 3, pause: float = 0.8) -> pd.DataFrame | None:
    """
    Try two paths with retries:
      A) Ticker().history(period="max")
      B) yf.download(period="max")
    Return a 1-col DataFrame ['price_usd'] (tz-naive) or None.
    """
    def _pick_price_column(df: pd.DataFrame):
        # Handle both single- and multi-index columns
        if isinstance(df.columns, pd.MultiIndex):
            for target in ("Adj Close", "Close"):
                candidates = [c for c in df.columns if (isinstance(c, tuple) and c[-1] == target)]
                if candidates:
                    return candidates[0]
            return None
        else:
            if "Adj Close" in df.columns:
                return "Adj Close"
            if "Close" in df.columns:
                return "Close"
            return None

    def _standardize(df: pd.DataFrame) -> pd.DataFrame | None:
        if df is None or df.empty:
            return None
        col = _pick_price_column(df)
        if col is None:
            return None
        series = df[col].dropna()
        out = series.to_frame(name="price_usd")
        out = _flatten_columns(out)
        if out.empty:
            return None
        out.index = pd.to_datetime(out.index)
        try:
            out.index = out.index.tz_localize(None)
        except Exception:
            pass
        return out.sort_index()

    # Path A
    for _ in range(retries):
        try:
            t = yf.Ticker(ticker)
            df = t.history(period="max", interval="1d", auto_adjust=True, actions=False)
            out = _standardize(df)
            if out is not None:
                return out
        except Exception:
            pass
        time.sleep(pause)

    # Path B
    for _ in range(retries):
        try:
            df = yf.download(
                ticker, period="max", interval="1d",
                auto_adjust=True, progress=False, actions=False, threads=False,
            )
            out = _standardize(df)
            if out is not None:
                return out
        except Exception:
            pass
        time.sleep(pause)

    return None


def fetch_gold_history(prefer_yahoo_only: bool = True) -> pd.DataFrame:
    """
    Fetch historical gold prices since the earliest available date (daily).
    Chooses the earliest-starting of: GC=F, MGC=F, GLD, IAU, SGOL.
    If all Yahoo calls fail and prefer_yahoo_only=False, falls back to FRED LBMA.
    """
    yahoo_candidates = [
        ("GC=F",  "COMEX Gold Futures (Continuous)"),
        ("MGC=F", "Micro Gold Futures"),
        ("GLD",   "SPDR Gold Shares ETF"),
        ("IAU",   "iShares Gold Trust"),
        ("SGOL",  "Aberdeen Standard Physical Gold Shares"),
    ]

    best_df = None
    best_meta = None

    for ticker, label in yahoo_candidates:
        df = _try_yahoo_history(ticker, retries=5, pause=1.0)
        if df is None or df.empty:
            continue
        if best_df is None or df.index.min() < best_df.index.min():
            best_df = df
            best_meta = (ticker, label)

    if best_df is not None:
        tkr, label = best_meta
        print(f"Using {label} [{tkr}] from {best_df.index.min().date()} to {best_df.index.max().date()} ({len(best_df):,} rows).")
        return best_df

    if prefer_yahoo_only:
        raise RuntimeError(
            "Yahoo Finance returned no data for GC=F, MGC=F, GLD, IAU, or SGOL. "
            "This may be due to yfinance version, network, or regional restrictions."
        )

    # FRED fallback
    try:
        from pandas_datareader import data as pdr
        fred = pdr.DataReader("GOLDAMGBD228NLBM", "fred")  # USD/oz, business days
        fred = fred.rename(columns={"GOLDAMGBD228NLBM": "price_usd"}).dropna()
        fred.index = pd.to_datetime(fred.index)
        fred = fred.sort_index()
        print(f"Using FRED LBMA Gold (AM London Fix) from {fred.index.min().date()} to {fred.index.max().date()} ({len(fred):,} rows).")
        return fred
    except Exception as e:
        raise RuntimeError(
            "No Yahoo data found, and FRED fallback also failed. "
            "Check internet access and update 'yfinance' and 'pandas_datareader'."
        ) from e


def fetch_sp500_history() -> pd.DataFrame:
    """
    Return S&P 500 (^GSPC) as 1-col DataFrame ['price_usd_sp500'] with a normalized DatetimeIndex.
    Uses the same robust Yahoo fetch path as gold to avoid schema surprises.
    """
    df = _try_yahoo_history("^GSPC", retries=5, pause=1.0)
    if df is None or df.empty:
        raise RuntimeError("Failed to fetch S&P 500 (^GSPC) from Yahoo Finance.")
    df = df.rename(columns={"price_usd": "price_usd_sp500"})
    return df


# ------------------------------------------------------------------
# -------------------- Part 2 – SQL Server CPI data --------------------
# ------------------------------------------------------------------

def fetch_cpi_yoy_from_sql() -> pd.DataFrame:
    """Pull CPI YoY from SQL Server: [Main].[fred].[F_C_CPI_YoY] with columns (date, value)."""
    server = r'Don_PC\SQLEXPRESS'   # <-- adjust if needed
    database = 'Main'

    conn_str = (
        r'DRIVER={ODBC Driver 17 for SQL Server};'
        f'SERVER={server};'
        f'DATABASE={database};'
        'Trusted_Connection=yes;'
    )

    query = """
        SELECT
            date,
            value
        FROM Main.fred.F_C_CPI_YoY
        WHERE date IS NOT NULL
          AND value IS NOT NULL
        ORDER BY date
    """

    try:
        with pyodbc.connect(conn_str) as conn, conn.cursor() as _:
            df = pd.read_sql(query, conn)
            if df.empty:
                raise ValueError("CPI table returned no rows")
            df['date'] = pd.to_datetime(df['date'])
            df.set_index('date', inplace=True)
            df.rename(columns={'value': 'cpi_yoy'}, inplace=True)
            df = df.astype({'cpi_yoy': float})
            return df.sort_index()
    except Exception as exc:
        raise RuntimeError(f"Failed to read CPI data from SQL Server: {exc}") from exc


# ------------------------------------------------------------------
# -------------------- Part 3 – Inflation adjustment --------------------
# ------------------------------------------------------------------

def build_cpi_inflation_factor(cpi_yoy_df: pd.DataFrame) -> pd.Series:
    """Convert a YoY percentage series into a cumulative inflation factor (base = 1 at start)."""
    growth_multiplier = 1 + cpi_yoy_df['cpi_yoy'] / 100.0
    inflation_factor = growth_multiplier.cumprod()
    inflation_factor /= inflation_factor.iloc[0]
    return inflation_factor


def adjust_prices_for_inflation(price_series: pd.Series,
                                inflation_factor: pd.Series) -> pd.DataFrame:
    """
    Multiply each gold price by the corresponding cumulative CPI factor.
    Returns DataFrame with: ['price_usd', 'cpi_factor', 'price_adj'].
    """
    df = pd.concat(
        [price_series.rename('price_usd'), inflation_factor.rename('cpi_factor')],
        axis=1
    ).dropna()
    df['price_adj'] = df['price_usd'] * df['cpi_factor']
    return df


# ------------------------------------------------------------------
# -------------------- Part 4 – Year-on-Year change --------------------
# ------------------------------------------------------------------

def compute_yoy_change(series: pd.Series) -> pd.Series:
    """Compute year-on-year % change: compares to the same calendar date one year earlier."""
    shifted = series.shift(1, freq=pd.DateOffset(years=1))
    yoy_pct = (series / shifted - 1.0) * 100.0
    return yoy_pct


# ------------------------------------------------------------------
# -------------------- Part 5 – Plotting + Tables -----------------------
# ------------------------------------------------------------------

def _monthly_diff_grid(df: pd.DataFrame, other_col: str) -> tuple[pd.DataFrame, pd.Series]:
    """
    Build a months (rows) x years (cols) grid of the percentage-point difference:
        diff = gold_raw_yoy - df[other_col]
    Returns (grid_df, avg_by_year).
    """
    diff = (df['gold_raw_yoy'] - df[other_col]).dropna()
    if diff.empty:
        # Create an empty frame to avoid crashes downstream
        return pd.DataFrame(), pd.Series(dtype=float)

    years = sorted(diff.index.year.unique())
    months = list(range(1, 13))
    grid = pd.DataFrame(index=months, columns=years, dtype=float)

    for y in years:
        for m in months:
            vals = diff[(diff.index.year == y) & (diff.index.month == m)]
            grid.loc[m, y] = vals.mean() if len(vals) else float('nan')

    avg_by_year = grid.mean(axis=0, skipna=True)
    return grid, avg_by_year


def _render_monthly_table(ax, grid: pd.DataFrame, avg_by_year: pd.Series, title_suffix: str):
    """
    Render a color-coded table on ax:
    - Green where diff >= 0, red where diff < 0, grey for NaN
    - Adds a final row "Average yearly performance"
    """
    ax.axis('off')
    if grid.empty:
        ax.text(0.5, 0.5, f"No data available for {title_suffix}", ha='center', va='center')
        return

    # Compose table text and colors
    month_names = ['Jan','Feb','Mar','Apr','May','Jun','Jul','Aug','Sep','Oct','Nov','Dec']
    years = list(grid.columns.astype(int))
    rows = month_names + ['Average yearly performance']

    # cell text (values as ±X.X pp) and colors
    cell_text = []
    cell_colors = []
    def fmt(x):
        if pd.isna(x):
            return '—'
        return f"{x:+.1f}"

    def cell_color(x):
        if pd.isna(x):
            return '#f2f2f2'  # light grey for missing
        return '#c6efce' if x >= 0 else '#ffc7ce'  # green if gold ≥ other, else red

    for m in range(1, 13):
        row_vals = [grid.loc[m, y] for y in years]
        cell_text.append([fmt(v) for v in row_vals])
        cell_colors.append([cell_color(v) for v in row_vals])

    # Average yearly performance row
    avg_vals = [avg_by_year.get(y, float('nan')) for y in years]
    cell_text.append([fmt(v) for v in avg_vals])
    cell_colors.append([cell_color(v) for v in avg_vals])

    the_table = ax.table(
        cellText=cell_text,
        rowLabels=rows,
        colLabels=[str(y) for y in years],
        cellColours=cell_colors,
        loc='center'
    )
    the_table.auto_set_font_size(False)
    the_table.set_fontsize(8)
    the_table.scale(1.0, 1.2)  # a bit taller for readability


def plot_comparison_with_table(df: pd.DataFrame, other_col: str, other_label: str, title: str):
    """
    Plot gold YoY vs another YoY series with shading, and place a monthly
    color-coded table underneath showing (gold_raw_yoy - other_yoy).
    """
    # Layout: top plot, bottom table
    fig = plt.figure(figsize=(14, 8))
    gs = fig.add_gridspec(nrows=2, ncols=1, height_ratios=[3, 2])
    ax_plot = fig.add_subplot(gs[0, 0])
    ax_table = fig.add_subplot(gs[1, 0])

    # --- Plot (top)
    ax_plot.plot(df.index, df[other_col], label=other_label, color='black', linewidth=1.5)
    ax_plot.plot(df.index, df['gold_raw_yoy'], label='Gold YoY (nominal)',
                 color='blue', linestyle='dotted', linewidth=1.5)

    ax_plot.fill_between(
        df.index, df[other_col], df['gold_raw_yoy'],
        where=(df['gold_raw_yoy'] >= df[other_col]),
        interpolate=True, color='green', alpha=0.4, label=f'Gold > {other_label}'
    )
    ax_plot.fill_between(
        df.index, df[other_col], df['gold_raw_yoy'],
        where=(df['gold_raw_yoy'] < df[other_col]),
        interpolate=True, color='red', alpha=0.4, label=f'Gold < {other_label}'
    )

    ax_plot.set_title(title, fontsize=14)
    ax_plot.set_xlabel('Date')
    ax_plot.set_ylabel('YoY %')
    ax_plot.grid(True, which='both', linestyle='--', linewidth=0.5)
    ax_plot.xaxis.set_major_locator(mdates.YearLocator(1))
    ax_plot.xaxis.set_major_formatter(mdates.DateFormatter('%Y'))
    fig.autofmt_xdate()
    ax_plot.legend(loc='center left', bbox_to_anchor=(1, 0.5))

    # --- Table (bottom)
    grid, avg_by_year = _monthly_diff_grid(df, other_col)
    _render_monthly_table(ax_table, grid, avg_by_year, title_suffix=other_label)

    plt.tight_layout()
    plt.show()


# ------------------------------------------------------------------
# -------------------- Part 6 – Main ------------------------------------
# ------------------------------------------------------------------

def main():
    # Pull GOLD series
    gold_df = fetch_gold_history(prefer_yahoo_only=False)

    # 20-second pause between Yahoo calls
    print("Waiting 20 seconds before fetching S&P 500 from Yahoo...")
    time.sleep(20)

    # Pull S&P 500 and CPI
    sp500_df = fetch_sp500_history()
    cpi_df   = fetch_cpi_yoy_from_sql()

    # Normalize indices
    gold_df  = _normalize_index(gold_df).rename(columns={"price_usd": "price_usd_gold"})
    sp500_df = _normalize_index(sp500_df)  # already 'price_usd_sp500'
    cpi_df   = _normalize_index(cpi_df)

    # Single inner join on the index across all three
    merged = pd.concat([gold_df, cpi_df[['cpi_yoy']], sp500_df], axis=1, join='inner')

    # Build cumulative CPI factor and inflation-adjust gold (for reference)
    inflation_factor = build_cpi_inflation_factor(merged[['cpi_yoy']])
    adjusted = adjust_prices_for_inflation(merged['price_usd_gold'], inflation_factor)
    adjusted['gold_adj_yoy'] = compute_yoy_change(adjusted['price_adj'])

    # Nominal YoY changes
    merged['gold_raw_yoy']  = compute_yoy_change(merged['price_usd_gold'])
    merged['sp500_raw_yoy'] = compute_yoy_change(merged['price_usd_sp500'])

    # Final DF (no printing per request)
    final_df = pd.concat(
        [merged[['cpi_yoy', 'gold_raw_yoy', 'sp500_raw_yoy']],
         adjusted[['price_adj', 'gold_adj_yoy']]],
        axis=1
    ).dropna()
    final_df.index.name = 'date'

    # Plot 1: Gold (nominal) YoY vs CPI YoY + monthly diff table
    plot_comparison_with_table(
        df=final_df,
        other_col='cpi_yoy',
        other_label='CPI YoY',
        title='Year-on-Year Change: Gold (nominal) vs CPI'
    )

    # Plot 2: Gold (nominal) YoY vs S&P 500 YoY + monthly diff table
    plot_comparison_with_table(
        df=final_df,
        other_col='sp500_raw_yoy',
        other_label='S&P 500 YoY',
        title='Year-on-Year Change: Gold (nominal) vs S&P 500'
    )

    return final_df


if __name__ == "__main__":
    main()
